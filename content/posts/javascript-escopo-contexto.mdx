---
title: "JavaScript: Qual a diferen√ßa entre Escopo e Context?"
date: 2020-02-05
---

Existem conceitos no JS (JavaScript) que acabam sendo muito confundidos. Um deles que acaba sendo muito recorrente √© diferenciar Escopo de Contexto. Este artigo √© baseado nos v√≠deos da s√©rie [What Makes Javascript Weird...and Awesome](https://www.youtube.com/playlist?list=PLoYCgNOIyGABI011EYc-avPOsk1YsMUe_) do canal do YouTube [LearnCode.academy](https://www.youtube.com/learncodeacademy/).

## Escopo

Escopo tem a ver com acessibilidade de vari√°veis, seja dentro de _if's_, _for's_, fun√ß√µes e etc. Por exemplo, veja o trecho de c√≥digo abaixo:

```javascript
var nome = "Lucas"
```

√â uma simples declara√ß√£o de vari√°vel. Digamos que o trecho acima esteja sendo executado dentro do browser. Vari√°veis declaradas no _root scope_ (escopo global) s√£o atribu√≠das ao objeto global `window`. Se no browser eu executar `console.log(nome)` ser√° exibido no `console`: "Lucas".

As vari√°veis com um escopo maior, podem ser acessadas por escopos menores. O termo correto √© _Parent scope_ para o escopo mais alto e para o escopo menor √© _Child scope._ Por√©m isto n√£o acontece inversamente, ou seja, v√°riaveis em escopos filhos n√£o podem ser acessadas por escopos pai, veja o trecho a seguir:

```javascript
var nome = "Lucas"

function declaraSobrenome() {
  console.log(nome) // Lucas
  var sobrenome = "Viana"
}

declaraSobrenome()

console.log(`${nome} ${sobrenome}`) // Uncaught ReferenceError: sobrenome is not defined
```

H√° uma coisa interessante com os escopos. J√° que os escopos filho n√£o podem ser acessados por escopos pai, eles podem sobrescrever os escopos-pai (O termo para isto √© _name conflict_). Ou seja, o c√≥digo abaixo √© v√°lido:

```javascript
var nome = "Lucas"

function sobrescreveNome() {
  var nome = "Jonas"
  console.log(window.nome) // Lucas
  console.log(nome) // Jonas
}

sobrescreveNome()

console.log(nome) // Lucas
```

E para finalizar, analise o c√≥digo abaixo e responda: o que ser√° exibido como nome no console?

```javascript
var nome = "Lucas"

function sobrescreveNome() {
  var nome = "Jonas"
}

function sobrescreveNomeDenovo() {
  nome = "Maria"
}

sobrescreveNome()
sobrescreveNomeDenovo()

console.log(nome) // O que ser√° impresso no console?
```

Sim, voc√™ acertou. Ser√° impresso "Maria". Isto acontece, pois antes do ES6 (onde temos diferentes formas de declarar vari√°veis com `let` e `const`) haviam muitos problemas com polui√ß√£o do _Root scope_, j√° que uma declara√ß√£o sem o `var` pode resultar em uma declara√ß√£o global. Por√©m, fa√ßa o seguinte teste: rode o mesmo c√≥digo do trecho anterior, por√©m com uma declara√ß√£o `"use strict"` no topo do arquivo, voc√™ ver√° que n√£o ser√° poss√≠vel sobrescrever o _Root scope_.

## Contexto

√â ligado √† palavra especial `this`. Em uma analogia, pensando em nosso mundo, o contexto nada mais √© do que o "espa√ßo" que determinada vari√°vel ocupa (vari√°vel no sentido mais amplo, podendo ser uma fun√ß√£o tamb√©m) no ambiente.

Agora sendo um pouco mais o t√©cnico, o `this` possui o mesmo comportamento do que qualquer outra vari√°vel, com a condi√ß√£o de que ele n√£o pode ser mudado. Isto porque o `this` √© alterado de outras formas que veremos a seguir.

O this referencia a um objeto de contexto, sendo um objeto podemos ter acesso a suas propriedades. Por exemplo, utilizando-se do exemplo anterior digamos que temos fun√ß√£o que exibe um nome e sobrenome como o c√≥digo a seguir:

```javascript
var nome = "Lucas"
var sobrenome = "Viana"

function exibeNomeCompleto() {
  return `${this.nome} ${this.sobrenome}`
}

console.log(exibeNomeCompleto()) // Lucas Viana
```

No ambiente de browsers, onde o JS pode ser executado, o contexto global para o `this` √© a `window`. Como aprendemos na se√ß√£o de Escopo, as vari√°veis globais s√£o declaradas na `window` , portanto o `this` tem acesso a estas vari√°veis globais no exemplo anterior.

Agora por exemplo, e se eu tiver um novo objeto que referencia o `this`? No c√≥digo abaixo √© poss√≠vel ver isto acontecer:

```javascript
var nome = "Lucas"
var sobrenome = "Viana"

var Pessoa = {
  nome: "Jos√©",
  sobrenome: "Augusto",
  exibeNomeCompleto: function() {
    return `${this.nome} ${this.sobrenome}`
  },
}

var exibeNomeCompleto = Pessoa.exibeNomeCompleto

console.log(Pessoa.exibeNomeCompleto()) // Jos√© Augusto
console.log(exibeNomeCompleto()) // Lucas Viana
```

E porque no exemplo anterior os nomes foram exibidos com valores diferentes? Isto acontece pois em `Pessoa` o contexto estava contido em `Pessoa` , por√©m quando foi atribu√≠do a uma vari√°vel no _Root_ _Scope_ o contexto mudou para `Window` .

Como dito anteriormente, **n√£o √© poss√≠vel** mudar o valor de `this`, por√©m √© poss√≠vel alterar o contexto de alguma vari√°vel, existem 3 m√©todos para alterar o contexto de algo, eles s√£o: `call`, `apply` e `bind`.

### Call

O m√©todo `call` √© respons√°vel por executar uma fun√ß√£o e em seu primeiro par√¢metro √© passado o contexto que ser√° aplicado nesta execu√ß√£o, por exemplo:

```javascript
var nome = "Lucas"
var sobrenome = "Viana"

var Pessoa = {
  nome: "Jos√©",
  sobrenome: "Augusto",
  exibeNomeCompleto: function() {
    return `${this.nome} ${this.sobrenome}`
  },
}

console.log(Pessoa.exibeNomeCompleto.call(window)) // Lucas Viana
```

O m√©todo `call` aceita outros par√¢metros que ser√£o utilizados pela fun√ß√£o executada, por exemplo:

```javascript
var nome = "Lucas"
var sobrenome = "Viana"

var Pessoa = {
  nome: "Jos√©",
  sobrenome: "Augusto",
  saudacoes: function(cidade, sigla) {
    return `Ol√° ${this.nome} ${this.sobrenome}, bem-vindo a ${cidade}/${sigla}`
  },
}

console.log(Pessoa.saudacoes.call(window, "S√£o Vicente", "SP")) // Ol√° Lucas Viana, bem-vindo a S√£o Vicente/SP
```

### Apply

O m√©todo `apply` √© basicamente a mesma coisa que o m√©todo `call`, com a √∫nica diferen√ßa que ele aceita apenas dois par√¢metros (no m√©todo `call` voc√™ pode passar qualquer n√∫mero de par√¢metros) sendo o primeiro o contexto em que ser√° executada a fun√ß√£o e o segundo um `array` com os par√¢metros.

A maioria das pessoas n√£o entende a diferen√ßa entre os dois m√©todos (achando que servem para a mesma coisa, mas n√£o). O m√©todo `apply` √© √∫til no caso de voc√™ manipular dados previamente e querer os repassar para alguma fun√ß√£o, no `call` voc√™ ficaria limitado em passar par√¢metro a par√¢metro os dados, j√° no `apply` voc√™ consegue manipular e passar diretamente para o m√©todo.

```javascript
var Calculadora = {
  soma: function(...numeros) {
    return numeros.reduce((acc, cur) => acc + cur, 0)
  },
}

var numeros = Array(8)
  .fill(1)
  .map((_, index) => index + 1)

Calculadora.soma(1, 1, 2) // 4
Calculadora.soma.apply(window, numeros) // 36
```

### Bind

O m√©todo bind √© um pouco diferente, mas nem tanto. A diferen√ßa √© que ele n√£o executa a fun√ß√£o, por√©m retorna sua declara√ß√£o contendo o contexto passado a ele como par√¢metro. Usando um dos exemplos anteriores, temos:

```javascript
var nome = "Jorge"
var sobrenome = "Luiz"

var Pessoa = {
  saudacoes: function(cidade, sigla) {
    return `Ol√° ${this.nome} ${this.sobrenome}, bem-vindo a ${cidade}/${sigla}`
  },
}

var saudarAlguem = Pessoa.saudacoes.bind(window)
saudarAlguem("Salvador", "BA") // // Ol√° Jorge Luiz, bem-vindo a Salvador/BA
```

Espero que tenham gostado da explica√ß√£o sobre a diferen√ßa entre Escopo e Contexto no JavaScript, se tiver alguma d√∫vida, coment√°rio ou sugest√£o procure por @mechamobau no [Twitter](https://twitter.com/mechamobau) e no [GitHub](https://github.com/mechamobau).

Lembrando que este maravilhoso blog encontra-se em c√≥digo aberto no meu GitHub. Caso queira ver o c√≥digo ou realizar alguma melhoria [visite https://github.com/mechamobau/blog](https://github.com/mechamobau/blog). Eu agrade√ßo üòÑ

Valeu meus queridos! ‚öõÔ∏è
